package Polymorphism;
/*
一个对象有多个形态 称为多态
父类引用指向子类对象就体现了代码的多态性
父类名称 对象名=new 子类名称（）；
接口名称 对像名=new 子类名称（）；

成员方法的使用规则
    new的是谁 就优先使用谁的方法 没有就找向上找 看看祖宗们有没有
口诀：编译看左边，运行看右边  这是成员方法的规则
 成员变量是 编译看左边 运行还是看左边 哪怕是子类对象有相同的成员变量

 向上转型以及向下转型
    1.多态写法 实际上就是向上转型 父类名称 对象名 = new 子类对象（）；
         含义 右侧创建一个子类对象 但是是把他当作父类来看待。   比如 创建了一个只猫 把它当作动物看来
         向上转型一定是安全的，这是从小范围向大范围的转换 也是功能由复杂的向功能简单的转换
         注意：一旦向上转型成为了父类 ，那么久不能使用子类特有的方法
    2.对象的向下转型
         为了能够实现子类的某些特殊方法，将其转换为其原来本身的样子 就是将子类看做了父类之后再还原来成子类
         子类名称 对象名 =（子类名称）父类对象；
         注意这个父类对象是由子类多态变看成的父类 一定是安全的
         但是如果本来不是子类的对象 非要转换成子类对象 那就出现了问题 就不安全了
         例如 本来是一只猫 多态之后看作一个一个动物父类 现在进行向下转型 硬是把她转化成一只狗  那么久出线了问题了

 */
public class What {
    public static void main(String[] args) {
        Fu zi = new Zi();//这就是多态  左父右子  把一个子类当作父类来看 因为子类包括父类所有的东西 但是父类如果没有的就不能调用 因为编译都通过不了
        zi.method();//创建的对象所用的方法依旧是子类的方法 new的子类就优先使用子类的方法 如果子类没有就会看父类是否有所需的方法
//        zi.age; 这就不对了 以为父类压根就没有
        ((Zi) zi).methodzi();//这是涉及到了强制类型转换  将父类又向下转型 转换成了一个子类对象 然后就可以调用子类对象特有的方法。
    }
}
