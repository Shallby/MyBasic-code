package DateStructor;
/*
栈就是先进后出  就一个口 先来的就落在了底部
堆就是先进先出  两个口 前后顺畅 先进来的就新出去了
1.数组：查询快 增删慢 增删慢是因为每次添加新元素的时候就要重新new一个对象 重新放入或者删除相应的各种元素 然后再将地址值给变量名 原数组就会被jvm自动回收
                   由于数组是连续的 知道首地址就可以利用索引任意查询各个元素
                   在堆内存中就要反复创建对象 效率低下
  链表：查询慢 增删快 查询慢是因为每次都是从头开始查询 不管查询第几个元素 因为链表在内存中不是一块连续的区域，每一个元素都称之为节点 一个节点包含了存储数据的数据源
                   和存储地址的两个指针域   他的增删都是直接将对应一个地址值添加到一个链表中去 对整体的链表影响基本没有

       单向链表：只有一条链子 不能保证元素的顺序 也就是存储元素和取出元素他的顺序有可能不一致 0x11 date 0x22           0x22 date2 0x73   0x73 date3 0x99........
       双向链表：链表中有两条链子，其中一条是专门记录元素循序的  他是一个有序的 0x11 date 0x22           0x22 date2 0x73   0x73 date3 0x99........
                                                             双向是链子可以上下都记录 也就是上一个元素知道下一个元素的地址  反过来 下一个也会记录上一个元素的地址

 2.红黑树
       计算机的树  哦都是一个倒着的 根在头上   称为树根
       下面的称为分支
    二叉树：分支不能超过两个 一个节点下面可以有一个分支 也可以有两个分支  左边的分支成为左子树 左孩子
    排序树：也称为查找树，在二叉树的基础上，元素是有大小顺序的
                            特点是 ：                左子树小 右子树大    查询的速度特别快
    平衡树：左孩子的数量和右孩子的数量是相等的 两边一样的多
  不平衡树：左右孩子数不一样多
    红黑树：特点：趋近于平衡树，查询叶子节点最大次数和最小次数不能超过2倍

 了解一下约束：
        1.节点可以红色的或者黑色的
        2，根节点是黑色的
        3，叶子节点（空节点）是黑色的
        4.每个红色的节点的子节点都是黑色的
        5.任何一个节点到每一个叶子节点的所有路径上黑色节点数相同



 */
public class Heap {
}
