package Demo02;
/*
如何区分子父局部变量的重名呢
局部变量：
本类中的成员变量；
父类中的成员变量；

override 覆盖父类的方法
注意事项：
    1.必须要子父方法同名，而且参数列表也相同 就是完全一模一样  而成员方法的重载只是方法的名字一致 但是参数列表不能相同
    @override写在方法前面  注解 用来检测是否进行了有效的重写
    2.子类方法的返回值必须小于等类父类方法的返回值范围。
object类是所有类的祖宗类 所有类的父类
    3.成员方法的权限修饰符
    子类方法的权限修饰符必须大于等于父类的权限修饰符
public》protected》（default）就是什么也没有写  直接void 成员方法名 （）{}》private

实际上 方法的override都是选用什么都一致  也就是 权限修饰符  返回值类型 方法名 （参数列表）全都是一致

特点：创建的是子类对象，则优先用子类的方法 优先
 */
public class ExtendField {
    public static void main(String[] args) {
        Zi zi=new Zi();
        zi.show();

        zi.MthodFu();//这个实际上调用不是父类的方法 恰恰相反 这个时候调用的是子类本身的
        //如何在override之后还要去调用父类的方法呢？重写,覆盖了父类的方法 overload 重载
        zi.call();//这都是覆盖重写 可以用super.方法名继续调用父类方法

    }
}
